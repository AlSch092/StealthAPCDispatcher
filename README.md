# StealthAPCDispatcher - Windows, C++
Schedules functions to be executed via user APC by using direct syscalls within an encrypted shellcode. Perfect for stealth operations in red-teams, anti-cheat, cheats, etc.  

Works by using C++ template recursion to pack parameters into a structure object, which is then passed to the APC routine. This method supports any number of parameters and works elegantly to hide function exeuction for routines which would normally be in their own threads, allowing you to avoid using `CreateThread` or similar. We use one APC sleeper thread which sleeps infinitely until woken up by a scheduled/queued routine, meaning work can be scheduled without any subsequent calls to `CreateThread`, since queued routines are executed in the context of the sleeper thread. Because we are using encrypted shellcode with a direct `syscall`, execution of our queued tasks cannot be tampered with easily at the usermode level (through API hooking or WINAPI patching). The downside is that routines are "queued" sequentially by the OS, and do not run parallel of eachother (which may imply slower execution times when compared to a pure multi-threaded application).  

Multiple fallback methods are present incase we cannot somehow allocate memory for shellcodes: the file `CallStub.asm` contains assembler routines which mimic `NtQueueApcThreadEx` and `NtQueueApcThreadEx2`, and we also have function pointer lookups which will directly call `NtQueueApcThreadEx2` (although this is not resistant to patches over this routine, which is why shellcode exeuction is the best execution method).  

Since different Windows builds might have different syscall dispatch numbers, you'll want to make sure that 0x166 and 0x167 are the correct ones for `NtQueueApcThreadEx` and `NtQueueApcThreadEx2` on your machine. These can be found by viewing these routines in a disassembler and seeing what number it is in the second instruction of the routine, which usually looks like `mov rax,00000166`.
